"""
The sequence of triangle numbers is generated by adding the natural numbers. 
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?


best version:

from itertools import *
from Queue import PriorityQueue
from math import sqrt

def is_prime(n):
    return all(n % p != 0 for p in takewhile(lambda p: p * p <= n, ps))

ps = [ 2 ]
def primes(k):
    if k < len(ps):
        return ps[k]
    
    for n in count(ps[-1] + 1):
        if is_prime(n):
            ps.append(n)
            if len(ps) > k:
                break
    return ps[k]

def value(es):
    return reduce(lambda x, (p, e): x * p ** e,
                            izip(imap(primes, count()), es), 1)

def num_divs(es):
    return reduce(lambda x, e: x * (e + 1), es, 1)

def gen_greater_combinations(N):
    pq = PriorityQueue()
    pq.put((2, (1,)))
    while not pq.empty():
        v0, es0 = pq.get()
        if num_divs(es0) > N:
            yield v0, es0
        es1 = (es0[0] + 1,) + es0[1:]
        pq.put((value(es1), es1))
        for k in xrange(1, len(es0)):
            if es0[k-1] == es0[k] + 1:
                es2 = es0[:k] + (es0[k] + 1,) + es0[k+1:]
                pq.put((value(es2), es2))
                break
            elif es0[k-1] > es0[k]:
                break
        else:
            if es0[-1] == 1:
                es2 = es0 + (1,)
                pq.put((value(es2), es2))

def is_descending(es):
    return all(e1 >= e2 for e1, e2 in izip(es, es[1:]))

def gen_greater_permutations(N):
    pq = PriorityQueue()
    g = gen_greater_combinations(N)
    set_used = set()
    pq.put(next(g))
    while not pq.empty():
        v, es0 = pq.get()
        yield v, es0
        for k in xrange(len(es0) - 1):
            if es0[k] > es0[k+1]:
                es1 = es0[:k] + (es0[k+1], es0[k]) + es0[k+2:]
                v1 = value(es1)
                if v1 not in set_used:
                    pq.put((v1, es1))
                    set_used.add(v1)
        if is_descending(es0):
            try:
                pq.put(next(g))
            except StopIteration:
                pass

def right_isolated_zero_pos(es):
    for k in xrange(len(es) - 2, 0, -1):
        if es[k] == 0:
            if es[k-1] > 0:
                return k
            else:
                return -1
    return -1

def gen_greater_numbers(N):
    pq = PriorityQueue()
    g = gen_greater_permutations(N)
    pq.put(next(g))
    while not pq.empty():
        v, es0 = pq.get()
        yield v
        
        es1 = es0[:-1] + (0, es0[-1])
        pq.put((value(es1), es1))
        
        pos = right_isolated_zero_pos(es0)
        if pos > 0:
            es2 = es0[:pos-1] + (0, es0[pos-1]) + es0[pos+1:]
            pq.put((value(es2), es2))
        
        if all(e > 0 for e in es0):
            try:
                pq.put(next(g))
            except StopIteration:
                pass

def is_triangle(n):
    m = int(sqrt(n * 2))
    return n == m * (m + 1) / 2

N = 50000
print next(ifilter(is_triangle, gen_greater_numbers(N)))
"""
import collections
import itertools
import time
start_time = time.time()
def triangle_number(n):
    return sum(range(n+1))




def prime_factors(n):
    i = 2
    while i * i <= n:
        if n % i == 0:
            n /= i
            yield i
        else:
            i += 1

    if n > 1:
        yield n


def prod(iterable):
    result = 1
    for i in iterable:
        result *= i
    return result


def get_divisors(n):
    pf = prime_factors(n)

    pf_with_multiplicity = collections.Counter(pf)

    powers = [
        [factor ** i for i in range(count + 1)]
        for factor, count in pf_with_multiplicity.items()
    ]

    for prime_power_combo in itertools.product(*powers):
        yield prod(prime_power_combo)


for i in itertools.count(1):
    tn = triangle_number(i)
    divisors = list(get_divisors(tn))
    if len(divisors) > 500:
        print(tn)
        break



print("--- %s seconds ---" % (time.time() - start_time))